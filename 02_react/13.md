<h1>Introdu√ß√£o a Context API: Estado Global da Aplica√ß√£o</h1>

Quando um componente depende do estado de outro componente, √© necess√°rio passar esse estado atrav√©s de propriedades (props) de pai para filho. Isso pode levar a uma cadeia longa de propriedades que precisam ser passadas, conhecida como "**prop drilling**". Al√©m disso, se um componente precisar atualizar o estado que √© compartilhado com outros componentes, ele precisar√° passar essa atualiza√ß√£o atrav√©s de seus componentes pai, tornando o c√≥digo mais complexo e dif√≠cil de manter.

IMAGEM PRINT (EXCALIDRAW PROP DRILLING)

Uma solu√ß√£o √© o uso da **Context API do React**, que permite compartilhar um estado a todos os componentes sem a necessidade de passar ao propriedades manualmente. A Context API √© uma alternativa **mais indicada para aplica√ß√µes menores e menos complexas** do que outros gerenciadores de estado, como por exemplo **Redux**.

IMAGEM PRINT (EXCALIDRAW CONTEXT API)

<h2><img src="https://i.imgur.com/H9wEgsJ.png" title="source: imgur.com" width="5%"/>1. Context API</h2>

A Context API √© uma **ferramenta da biblioteca React que permite o armazenamento de dados em uma "√°rvore" de objetos que podem ser acessados de forma global dentro de um aplicativo.** Essa √°rvore √© conhecida como "contexto" e pode ser usada para compartilhar informa√ß√µes entre diferentes componentes da interface do usu√°rio sem precisar passar as informa√ß√µes manualmente entre os componentes.

Essa estrat√©gia √© √∫til para situa√ß√µes em que v√°rios componentes precisam compartilhar informa√ß√µes em comum, como por exemplo: **informa√ß√µes de autentica√ß√£o do usu√°rio, tema da aplica√ß√£o, prefer√™ncias do usu√°rio, etc**. Em vez de passar essas informa√ß√µes para cada componente manualmente, a Context API permite armazen√°-las em um local centralizado e acess√°-las em qualquer lugar da aplica√ß√£o. 

No entanto, √© importante ter em mente que o uso excessivo do Context API pode levar a problemas de desempenho, e deve ser utilizado com modera√ß√£o e cuidado.

**O uso da Context API do React √© importante por diversas raz√µes, dentre elas podemos citar:**

* **Gerenciamento de Estado Global**: A Context API permite criar um estado global que pode ser compartilhado entre componentes sem a necessidade de passar props manualmente entre eles. Isso torna mais f√°cil e eficiente o gerenciamento do estado em toda a sua aplica√ß√£o.
* **Reduz o Acoplamento**: Ajuda a reduzir o acoplamento entre componentes, permitindo que eles permane√ßam mais independentes e reutiliz√°veis. Isso facilita a manuten√ß√£o e o teste dos componentes.
* **Melhora a Escalabilidade**: Conforme seu projeto React cresce, a Context API torna mais f√°cil adicionar, modificar ou remover funcionalidades de gerenciamento de estado global, mantendo a integridade do seu c√≥digo.
* **Customiza√ß√£o**: Voc√™ pode criar contextos personalizados, permitindo que diferentes partes da sua aplica√ß√£o tenham seu pr√≥prio contexto de estado, o que √© √∫til quando voc√™ precisa de diferentes tipos de estados globais.
* **Reduz a Necessidade de State Management Externo**: Em muitos casos, a Context API pode ser usada como uma alternativa a bibliotecas de gerenciamento de estado externo, como Redux, especialmente em projetos menores ou quando a complexidade do estado global √© limitada.
* **Centraliza√ß√£o do Estado**: A Context API permite centralizar o estado em um local, facilitando o monitoramento, a depura√ß√£o e o gerenciamento de estados em toda a aplica√ß√£o.
* **Desempenho Otimizado**: A Context API possui otimiza√ß√µes internas para evitar renderiza√ß√µes desnecess√°rias de componentes consumidores quando o estado √© atualizado.

<h2><img src="https://i.imgur.com/H9wEgsJ.png" title="source: imgur.com" width="5%"/>2. Estrutura da Context API</h2>

Dependendo da aplica√ß√£o que est√° sendo constru√≠da, a Context API pode conter v√°rias estruturas diferentes, mas apesar disso, podemos resumi-l√° em 3 por tr√™s partes principais: **o Contexto, o Provedor do Contexto (Provider) e o Consumo do Contexto.**

* **Contexto**: Ele √© um **componente .jsx/.tsx** que servir√° como um **cont√™iner para o estado global** que voc√™ deseja compartilhar entre componentes.
* **Provedor do Contexto (Provider):** Geralmente adicionado ao componente App (por geralmente ser o componente de maior n√≠vel superior da sua aplica√ß√£o), o componente **Provider** fornecido pelo contexto disponibiliza o estado global para os componentes descendentes. Voc√™ define o que ser√° compartilhado a aplica√ß√£o atrav√©s de uma **prop** do **Provider** chamada **value**.
* **Consumir o Contexto:** Em componentes filhos que estejam dentro do Componente Provider, e que desejam acessar o estado global, voc√™ usa o **Hook useContext** para consumir o contexto e obter o valor do estado global.

Para deixar esses tr√™s conceitos mais n√≠tidos, vamos a pr√°tica com um exemplo!

<h2><img src="https://i.imgur.com/H9wEgsJ.png" title="source: imgur.com" width="5%"/>3. Adicionando a Context API ao Projeto</h2>

Para ganharmos tempo, n√≥s j√° iremos criar uma organiza√ß√£o para futuramente adicionarmos os c√≥digos que ser√£o utilizados no Projeto, e iremos refor√ßar o entendimento da Context API com um exemplo. Por tanto, sigo os passos abaixo:

1. Clique com o bot√£o direito do mouse na pasta **src** e, crie uma nova pasta chamada **contexts**

2. Na sequ√™ncia, vamos criar o arquivo **AuthContext .tsx**, dentro da pasta.

3. Dentro do arquivo, adicione os seguintes c√≥digos:

   

   ```tsx
   
   ```

   

4. Seguindo esses passos, voc√™ deve ter uma estrutura id√™ntica a essa:





<h3>üë£ 2.2 Estrutura do hook useEffect em React</h3>





```
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import Footer from './components/footer/Footer';
import Navbar from './components/navbar/Navbar';
import Home from './pages/home/Home';
import { AuthProvider } from './contexts/AuthContext';

function App() {
    return (
        <AuthProvider>
            <BrowserRouter>
                <Navbar />
                <div className='min-h-[80vh]'>
                    <Routes>
                        <Route path="/" element={<Home />} />
                        <Route path="/home" element={<Home />} />
                    </Routes>
                </div>
                <Footer />
            </BrowserRouter>
        </ AuthProvider>
    );
}

export default App;
```





```
import { ReactNode, createContext, useState } from "react";

interface AuthContextProps {
    nome: string
    handleNovoNome: (nome: string) => void
}

interface AuthProviderProps {
    children: ReactNode
}

export const AuthContext = createContext({} as AuthContextProps)

export function AuthProvider({ children }: AuthProviderProps) {
    const [nome, setNome] = useState('Yuri');

    function handleNovoNome(nome: string) {
        setNome(nome)
    }

    return (
        <AuthContext.Provider value={{ nome, handleNovoNome }}>
            {children}
        </AuthContext.Provider>
    )
}
```



Antes de entrarmos no assunto Rotas, vamos relembrar O que √© um Componente React?

<div align="center"><img src="https://i.imgur.com/OnU3Myc.png" title="source: imgur.com" /></div>

***Um Componente React √© uma Fun√ß√£o JavaScript que retorna (renderiza no navegador) C√≥digo HTML e CSS.***

At√© o momento, voc√™ criou 3 Componentes na sua aplica√ß√£o:

- Navbar
- Home
- Footer

Os 3 Componentes criados foram inseridos dentro do Componente App, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/nmgCyMP.png" title="source: imgur.com" /></div>

A nossa aplica√ß√£o, n√£o ser√° composta por apenas 3 componentes, at√© porqu√™ o nosso Backend possui 17 endpoints, que podem ser consumidos. No Projeto React do Blog Pessoal, vamos construir os seguintes Componentes:

- Login
- Cadastro de Usu√°rio
- Listar Temas
- Listar Postagens
- Cadastrar/Atualizar Tema
- Cadastrar/Atualizar Postagem
- Deletar Tema
- Deletar Postagem

Ap√≥s a constru√ß√£o de todos estes componentes, todos eles dever√£o ser inseridos dentro do Componente App para ficarem dispon√≠veis na nossa aplica√ß√£o, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/xspilXg.png" title="source: imgur.com" /></div>

Entretanto, como vimos anteriormente no tema Componentes, se apenas adicionarmos os todos os componentes criados dentro do Componente APP, todos eles ser√£o renderizados (exibidos) no Navegador ao mesmo tempo e n√£o √© isso que n√≥s queremos. No est√°gio atual da nossa aplica√ß√£o, o React est√° fazendo exatamente isso: **Renderizando no Navegador todos os Componentes inseridos no Componente App, sem nenhum controle**.

O Comportamento esperado da nossa aplica√ß√£o √© que cada Componente seja exibido na tela, de acordo com a op√ß√£o do Menu (Componente Navbar), que foi escolhida, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/6kMaVhb.png" title="source: imgur.com" /></div>

Observe que no Componente Navbar, n√≥s temos 4 op√ß√µes no menu. Ao clicar em cada uma destas op√ß√µes, um componente diferente ser√° renderizado na √°rea onde est√° o Componente Home. Os Componentes **Navbar** e **Footer** ser√£o est√°ticos, enquanto a √°rea onde est√° o Componente Home ser√° din√¢mica.

Para conseguirmos obter o comportamento esperado e controlar exatamente quais Componentes ser√£o renderizados em cada op√ß√£o do menu, utilizaremos a Biblioteca **React Router**, que estabelecer√° Rotas (caminhos) para a nossa aplica√ß√£o, organizando a renderiza√ß√£o dos componentes.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

